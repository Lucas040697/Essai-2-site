<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Protocoles Sensoriels</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: An interactive dashboard-style single-page application. A persistent left-hand navigation sidebar allows users to select one of the 6 main sections of the protocol. The main content area dynamically displays the details of the selected section. This structure breaks down the dense report into manageable, task-oriented chunks, facilitating non-linear exploration and learning. This design prioritizes user understanding and ease of reference. -->
    <!-- Visualization & Content Choices: 
        - General Structure: Content is organized into expandable accordion cards for each of the 20 points, allowing users to fill in data. Goal: Organize & Collect Data. Method: HTML/CSS/JS.
        - PDF Export: A core feature to generate a document from the user-entered data. Goal: Output. Method: jsPDF library.
        - Interactive Generators: Buttons for generating random codes and Latin Squares/BIBD to assist in protocol creation. Goal: Automate & Assist. Method: JS DOM manipulation.
        - Decision Tree: An expert-driven interactive guide for selecting the correct test type, with breadcrumbs for tracking progress. Goal: Guide & Educate. Method: JS DOM manipulation.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f7f4; 
            color: #2d3748;
        }
        .nav-link {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            font-weight: 500;
            color: #4a5568;
        }
        .nav-link:hover {
            background-color: #e2e8f0;
        }
        .nav-link.active {
            background-color: #a78bfa; /* Soft Violet */
            color: #ffffff;
            font-weight: 600;
        }
        .nav-link .icon {
            margin-right: 0.75rem;
            width: 1.25rem;
            height: 1.25rem;
        }
        .accordion-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background-color: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        .accordion-header:hover {
            background-color: #fafafa;
        }
        .accordion-content {
            display: none;
            padding: 1.5rem;
            border: 1px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
            background-color: #ffffff;
        }
        .accordion-content.open {
            display: block;
        }
        .accordion-arrow {
            transition: transform 0.3s;
        }
        .accordion-header.open .accordion-arrow {
            transform: rotate(180deg);
        }
        .form-input, .form-textarea, .form-select {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            background-color: #fff;
        }
        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: #a78bfa;
            box-shadow: 0 0 0 2px rgba(167, 139, 250, 0.4);
        }
        .form-textarea {
            min-height: 120px;
            resize: vertical;
        }
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 9999;
        }
        .generator-button {
             background-color: #8b5cf6;
             color: white;
             font-weight: 500;
             padding: 0.5rem 1rem;
             border-radius: 0.375rem;
             transition: background-color 0.2s;
        }
        .generator-button:hover {
             background-color: #7c3aed;
        }
        .tree-node {
            padding: 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            background-color: white;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .tree-node:hover {
            border-color: #a78bfa;
            background-color: #f5f3ff;
        }
        .tree-node.selected {
            border-color: #8b5cf6;
            background-color: #ede9fe;
            font-weight: 600;
            color: #5b21b6;
        }
        .breadcrumb {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 1rem;
        }
        .feedback-message {
            margin-top: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            display: none;
        }
        .feedback-green {
            background-color: #dcfce7;
            color: #166534;
        }
        .feedback-orange {
            background-color: #ffedd5;
            color: #9a3412;
        }
        .feedback-red {
            background-color: #fee2e2;
            color: #991b1b;
        }
    </style>
</head>
<body class="antialiased">
    <div id="loading-overlay" style="display: none;">Opération en cours...</div>

    <div class="flex h-screen bg-gray-100">
        <aside class="w-72 bg-white shadow-md flex-shrink-0 flex flex-col">
            <div class="p-4">
                <h1 class="text-xl font-bold text-violet-700">Générateur de Protocole</h1>
                <p class="text-sm text-gray-500">Outil de rédaction</p>
            </div>
            <nav id="main-nav" class="p-4 space-y-2 flex-1 overflow-y-auto">
            </nav>
            <div class="p-4 border-t border-gray-200">
                <button id="export-pdf-button" class="w-full flex items-center justify-center gap-2 bg-violet-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-violet-700 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    Exporter en PDF
                </button>
            </div>
        </aside>

        <main id="main-content" class="flex-1 overflow-y-auto p-4 md:p-8">
            <div id="content-container">
            </div>
        </main>
    </div>

    <script>
        let formData = { 'nombreProduits': 1, 'panelSize': 1, 'produitsParSujet': 1 };
        let treeHistory = [];

        const protocolData = {
            sections: [
                 {
                    id: 'introduction',
                    title: 'Introduction',
                    icon: `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`,
                    content: `
                        <div class="bg-white p-6 rounded-lg shadow-sm">
                           <h2 class="text-2xl font-bold mb-4 text-violet-700">Bienvenue dans l’aide à la rédaction de Protocoles de tests terrain.</h2>
                            <p class="mb-4">Cet outil est conçu pour vous aider à rédiger des protocoles de tests terrain complets et standardisés. Remplissez les champs dans chaque section pour construire votre protocole pas à pas.</p>
                            <p>Vous pouvez ouvrir et fermer les sections en cliquant sur leur titre.</p>
                        </div>
                    `
                },
                {
                    id: 'identification',
                    title: '1. Identification & Contexte',
                    icon: `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002-2h2a2 2 0 002 2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>`,
                    items: [
                        { inputId: 'titre', title: '1. Titre du Protocole', explanation: 'Le titre est la première porte d\'entrée du document. Il doit être concis, tout en étant suffisamment clair et informatif pour permettre une identification rapide de l\'objet principal du test. Un bon titre facilite l\'organisation des études, leur archivage et leur recherche ultérieure.', example: 'Évaluation Hédonique Comparative de Trois Nouvelles Formulations de Boisson Énergisante', type: 'text' },
                        { inputId: 'identifiant', title: '2. Identifiant Unique', explanation: 'L\'attribution d\'un code unique à chaque protocole est une pratique indispensable pour assurer une traçabilité sans faille. Cet identifiant sert de lien entre le protocole, le rapport d\'analyse, les échantillons testés, les données brutes collectées et tout autre document relatif à l\'étude. Il prévient toute confusion. "[Numéro de laboratoire/Nom d’équipe/sport]-[AA]-[Numéro du test]”', example: 'L178-25-051', type: 'text' },
                        { inputId: 'responsable', title: '3. Responsable de l\'Étude', explanation: 'Il est crucial d\'identifier nommément la personne qui porte la responsabilité principale de l\'étude (conception, supervision, analyse, rapport). Cette identification clarifie les rôles et les responsabilités.', example: 'Lucas Blondel (Ingénieur Essais Terrain, NEC+)', type: 'text' },
                        { inputId: 'contexte', title: '4. Contexte et Justification', explanation: 'Cette section doit expliquer de manière concise mais claire les raisons pour lesquelles le test sensoriel est entrepris. Quel est le problème spécifique que l\'on cherche à résoudre? Quelle est la question précise à laquelle l\'étude doit apporter une réponse?', example: 'Assurer que la réduction de 8% de l’épaisseur de la semelle de la chaussure de basket n’engendre pas de diminution de la perception de l’amorti.', type: 'textarea' },
                        { inputId: 'problematiques', title: '5. Objectif(s) du test', explanation: 'Les objectifs spécifiques décrivent de manière précise et mesurable ce que l\'on cherche à déterminer grâce au test. Ils découlent directement du contexte et sont déterminants pour le choix de la méthodologie.', example: 'Déterminer si la chaussure avec une épaisseur de semelle de 12 mm (Produit A) est au moins autant appréciée que la chaussure référente à 13 mm d’épaisseur, concernant la sensation d’amorti (Produit B).', type: 'textarea' },
                        { inputId: 'resultatsAttendus', title: '6. Problématique', explanation: 'Formuler une problématique SMART (Ex : Évaluer la compatibilité du vélo avec un référent du marché / Évaluer le confort d’accueil d’une selle / etc).', example: 'La chaussure A est au moins autant appréciée que la chaussure B;', type: 'textarea' }
                    ]
                },
                 {
                    id: 'methodologie',
                    title: '2. Méthodologie',
                    icon: `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>`,
                    items: [
                        { 
                            id: 'testTypeTree',
                            title: '1. Type de Test', 
                            explanation: 'Indiquer clairement le type de test (Sensoriel, instrumental etc…)) et justifier ce choix en expliquant son adéquation avec les objectifs spécifiques. Chaque catégorie de test est conçue pour répondre à des questions distinctes.', 
                            type: 'interactive-tree'
                        },
                        { 
                            inputId: 'nombreProduits', 
                            title: '2. Nombre de produits', 
                            explanation: 'Indiquez le nombre total de produits qui seront évalués au cours de cette étude.', 
                            example: '3', 
                            type: 'select', 
                            options: Array.from({length: 50}, (_, i) => i + 1)
                        },
                        { 
                            id: 'dynamicProductContainer',
                            title: '3. Description du/des Produit(s)', 
                            explanation: 'Fournir une description exhaustive de chaque produit pour une traçabilité parfaite (marque, nom, version).', 
                            example: 'Gant de gardien 900, Kipsta, Prototype, version 3.2',
                            type: 'dynamic' 
                        },
                        { inputId: 'preparation', title: '4. Préparation et Présentation des Échantillons', explanation: 'Détailler toutes les étapes de préparation et de présentation (codage aléatoire à 3 chiffres, ordre contrebalancé) pour assurer l\'homogénéité et neutraliser les biais.', example: '', type: 'textarea' },
                        { 
                            interactive: true,
                            id: 'generatorCodage', 
                            title: '4.1 Codage des Échantillons', 
                            explanation: 'Le codage vise à prévenir tout biais de jugement. Utilisez ce générateur pour créer des codes aléatoires à 3 chiffres pour chaque produit décrit dans la section 3.',
                            content: `
                                <div class="flex flex-col items-center">
                                    <button id="code-generator-button" class="generator-button">Générer les Codes</button>
                                    <div id="code-generator-result" class="mt-4 p-4 w-full bg-gray-50 rounded-md border border-gray-200 min-h-[50px]">
                                        <p class="text-sm text-gray-500">Les codes générés s'afficheront ici.</p>
                                    </div>
                                </div>`
                        }
                    ]
                },
                {
                    id: 'panel',
                    title: '3. Panel de testeurs',
                    icon: `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>`,
                    items: [
                        { inputId: 'panelType', title: '1. Type de Panel', explanation: 'Décrire le type de panel (experts, consommateurs) en lien avec les objectifs. Un panel d\'experts pour la finesse descriptive, un panel de consommateurs pour l\'appréciation.', example: 'Panel de 60 utilisateurs de genouillères pour un test de préférence.', type: 'text' },
                        { inputId: 'recrutement', title: '2. Critères de Recrutement', explanation: 'Lister les critères de sélection (démographiques, morphologiques, habitudes d’utilisation/de consommation/). Un recrutement rigoureux est une condition de base pour la validité des résultats. Il est important de tout détailler est d’avoir un profil précis établi avec le Product Manager.', example: 'Femmes/Hommes, 30-55 ans, utilisateur de genouillères 2 à 3 fois par semaine, en moyenne durant la pratique sportive, depuis plus de 1 an et n’ayant pas eu de blessures au genoux sur la dernière année.', type: 'textarea' },
                        { 
                            inputId: 'panelSize', 
                            title: '3. Nombre de Sujets', 
                            explanation: 'Indiquer et justifier la taille du panel. Elle dépend du type de test, de la variabilité attendue et de la puissance statistique souhaitée.', 
                            example: '30', 
                            type: 'select',
                            options: Array.from({length: 100}, (_, i) => i + 1)
                        },
                        { 
                            inputId: 'produitsParSujet', 
                            title: '4. Produits testés par sujet', 
                            explanation: 'Indiquer combien de produits chaque sujet évaluera. Si ce nombre est inférieur au total, un plan en blocs incomplets sera généré.', 
                            example: '3', 
                            type: 'select',
                            options: [] // Will be populated dynamically
                        },
                        { inputId: 'formation', title: '5. Formation (si applicable)', explanation: 'Pour les panels entraînés, décrire le programme de formation (durée, méthodes, calibration sur les échelles et descripteurs).', example: 'Formation de 60h sur la texture des produits de panification, avec définition de références pour l\'intensité.', type: 'textarea' },
                        { inputId: 'consignes', title: '6. Consignes Avant le Test', explanation: 'Lister les instructions données aux sujets avant la séance pour minimiser les interférences sensorielles.', example: 'Ne pas fumer 2h avant la séance, ne pas utiliser de parfum le jour du test, venir à jeun depuis au moins 1h.', type: 'textarea' },
                        { 
                            interactive: true, 
                            id: 'generatorOrdre',
                            title: '7. Ordre de Présentation', 
                            explanation: 'Pour neutraliser les effets de rang, l\'ordre de présentation doit être contrebalancé. Utilisez ce générateur pour créer un plan adapté au nombre de produits et de sujets.',
                            content: `
                                <div class="flex flex-col items-center">
                                    <button id="latin-square-button" class="generator-button">Générer le Plan de Présentation</button>
                                    <div id="latin-square-result" class="mt-4 p-4 w-full bg-gray-50 rounded-md border border-gray-200 min-h-[50px] overflow-x-auto">
                                        <p class="text-sm text-gray-500">Le plan de présentation s'afficheront ici.</p>
                                    </div>
                                </div>`
                        }
                    ]
                },
                {
                    id: 'environnement',
                    title: '4. Environnement & Déroulement',
                    icon: `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path></svg>`,
                    items: [
                        { inputId: 'conditions', title: '1. Conditions de Test', explanation: 'Décrire l’endroit où le test aura lieu.', example: 'Terrain d’athlétisme.', type: 'textarea' },
                        { inputId: 'deroulement', title: '2. Déroulement de la Séance', explanation: 'Rédiger des instructions claires et standardisées données aux sujets, et décrire la fiche d\'évaluation (papier ou digitale) utilisée pour la collecte des réponses.', example: 'Instructions pour un test triangulaire lues au début de la séance, puis réponses collectées sur tablette via le logiciel FIZZ.', type: 'textarea' },
                        { inputId: 'materiel', title: '3. Matériel', explanation: 'Lister tout le matériel dont on aura besoin pour réaliser le test.', example: '- 10 modèles de la chaussure produit A en taille 43.\n- 10 modèles de la chaussure produit B en taille 43\n- 20 paires de chaussette (mettre le modèle de la chaussette)\n- 2 caméras sur pied\n- une tablette/ordi\n- 10 plots …', type: 'textarea' }
                    ]
                },
                {
                    id: 'analyse',
                    title: '5. Évaluation & Analyse',
                    icon: `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>`,
                    items: [
                        { inputId: 'echelles', title: '1. Descripteurs et Échelles de Mesure', explanation: 'Lister les attributs à évaluer et le type d\'échelle de mesure utilisée (ex: échelle hédonique à 9 points, échelle d\'intensité linéaire, échelle JAR). Le choix de l\'échelle est critique et dépend de la question posée.', example: 'Appréciation globale évaluée sur une échelle hédonique à 9 points. Intensité de l\'amertume sur une échelle JAR de 1 à 7.', type: 'textarea' },
                        { inputId: 'collecte', title: '2. Collecte et Enregistrement', explanation: 'Décrire comment les données sont collectées (papier, digital), enregistrées (logiciel, format) et vérifiées pour assurer leur intégrité. La traçabilité doit être parfaite.', example: 'Collecte sur tablette via google form.', type: 'text' },
                        { inputId: 'statistiques', title: '3. Analyse Statistique', explanation: 'Spécifier les méthodes statistiques utilisées (ex: ANOVA, Chi-deux, ACP) en adéquation avec le type de données et les objectifs. Le seuil de significativité retenu (généralement 5%) doit être mentionné.', example: 'ANOVA sur les notes hédoniques pour tester l\'effet produit, suivie de tests post-hoc de Tukey si p < 0.05.', type: 'textarea' },
                        { inputId: 'interpretation', title: '4. Critères d\'Interprétation des Résultats', explanation: 'Définir en amont comment les résultats seront interprétés. Une différence statistiquement significative est-elle pour autant commercialement pertinente ?', example: 'Une différence de note hédonique supérieure à 1 point sera considérée comme commercialement pertinente.', type: 'text' }
                    ]
                },
                {
                    id: 'annexes',
                    title: '6. Annexes',
                    icon: `<svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>`,
                    items: [
                        { inputId: 'annexes', title: 'Annexes', explanation: 'Lister les documents joints au protocole (modèles de fiches, questionnaires, plans détaillés) pour le rendre pleinement opérationnel et reproductible.', example: 'Annexe 1: Modèle du formulaire de consentement. Annexe 2: Modèle de la fiche d\'évaluation.', type: 'textarea' }
                    ]
                }
            ]
        };

        const toggleLoading = (isLoading, message = 'Opération en cours...') => {
            const overlay = document.getElementById('loading-overlay');
            overlay.textContent = message;
            if (isLoading) {
                overlay.style.display = 'flex';
            } else {
                overlay.style.display = 'none';
            }
        };

        function renderAccordions(items) {
            return items.map(item => {
                if (item.interactive) {
                     const savedCodesHtml = formData['generatedCodesHtml'] || '<p class="text-sm text-gray-500">Les codes générés s\'afficheront ici.</p>';
                     const savedLatinSquareHtml = formData['latinSquareHtml'] || '<p class="text-sm text-gray-500">Le plan de présentation s\'affichera ici.</p>';

                     let contentHtml;
                     if (item.id === 'generatorCodage') {
                         contentHtml = `<div class="flex flex-col items-center">
                                    <button id="code-generator-button" class="generator-button">Générer les Codes</button>
                                    <div id="code-generator-result" class="mt-4 p-4 w-full bg-gray-50 rounded-md border border-gray-200 min-h-[50px]">
                                        ${savedCodesHtml}
                                    </div>
                                </div>`;
                     } else if (item.id === 'generatorOrdre') {
                         contentHtml = `<div class="flex flex-col items-center">
                                    <button id="latin-square-button" class="generator-button">Générer le Plan de Présentation</button>
                                    <div id="latin-square-result" class="mt-4 p-4 w-full bg-gray-50 rounded-md border border-gray-200 min-h-[50px] overflow-x-auto">
                                        ${savedLatinSquareHtml}
                                    </div>
                                </div>`;
                     }

                     return `
                        <div class="mb-2">
                            <div class="accordion-header bg-white rounded-lg shadow-sm">
                                <h3 class="text-lg font-semibold">${item.title}</h3>
                                <svg class="accordion-arrow w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                            <div class="accordion-content">
                                <div class="space-y-4">
                                    <div>
                                        <h4 class="font-semibold text-violet-600">Explication Pédagogique</h4>
                                        <p class="mt-1 text-gray-700">${item.explanation}</p>
                                    </div>
                                    <div class="mt-4">
                                        ${contentHtml}
                                    </div>
                                </div>
                            </div>
                        </div>`;
                }

                if(item.type === 'dynamic'){
                     return `
                        <div class="mb-2">
                            <div class="accordion-header bg-white rounded-lg shadow-sm">
                                <h3 class="text-lg font-semibold">${item.title}</h3>
                                <svg class="accordion-arrow w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                            <div class="accordion-content">
                                <div class="space-y-4">
                                    <div>
                                        <h4 class="font-semibold text-violet-600">Explication Pédagogique</h4>
                                        <p class="mt-1 text-gray-700">${item.explanation}</p>
                                    </div>
                                    <div class="p-3 bg-gray-50 rounded-md border border-gray-200">
                                        <h4 class="font-semibold text-gray-600">Exemple</h4>
                                        <p class="mt-1 text-sm text-gray-800 italic">"${item.example}"</p>
                                    </div>
                                    <div id="${item.id}" class="mt-4">
                                        <!-- Dynamic product inputs will be rendered here -->
                                    </div>
                                </div>
                            </div>
                        </div>`;
                }

                if (item.type === 'interactive-tree') {
                    return `
                        <div class="mb-2">
                            <div class="accordion-header bg-white rounded-lg shadow-sm">
                                <h3 class="text-lg font-semibold">${item.title}</h3>
                                <svg class="accordion-arrow w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                            </div>
                            <div class="accordion-content">
                                <div class="space-y-4">
                                     <div>
                                        <h4 class="font-semibold text-violet-600">Explication Pédagogique</h4>
                                        <p class="mt-1 text-gray-700">${item.explanation}</p>
                                    </div>
                                    <div class="p-3 bg-gray-50 rounded-md border border-gray-200">
                                        <h4 class="font-semibold text-gray-600">Exemple</h4>
                                        <p class="mt-1 text-sm text-gray-800 italic">"${item.example}"</p>
                                    </div>
                                    <div id="decision-tree-container" class="mt-4"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                const savedValue = formData[item.inputId] || '';
                let inputElementHtml;

                switch (item.type) {
                    case 'textarea':
                        inputElementHtml = `<textarea id="${item.inputId}" class="form-textarea">${savedValue}</textarea>`;
                        break;
                    case 'select':
                        const optionsHtml = item.options.map(opt => 
                            `<option value="${opt}" ${savedValue == opt ? 'selected' : ''}>${opt}</option>`
                        ).join('');
                        inputElementHtml = `<select id="${item.inputId}" class="form-select">${optionsHtml}</select>`;
                        break;
                    default: // 'text' and others
                        inputElementHtml = `<input type="text" id="${item.inputId}" class="form-input" value="${savedValue}">`;
                        break;
                }

                return `
                <div class="mb-2">
                    <div class="accordion-header bg-white rounded-lg shadow-sm">
                        <h3 class="text-lg font-semibold">${item.title}</h3>
                        <svg class="accordion-arrow w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="accordion-content">
                        <div class="space-y-4">
                            <div>
                                <h4 class="font-semibold text-violet-600">Explication Pédagogique</h4>
                                <p class="mt-1 text-gray-700">${item.explanation}</p>
                            </div>
                            <div class="p-3 bg-gray-50 rounded-md border border-gray-200">
                                <h4 class="font-semibold text-gray-600">Exemple</h4>
                                <p class="mt-1 text-sm text-gray-800 italic">"${item.example}"</p>
                            </div>
                            <div class="mt-4">
                                <label for="${item.inputId}" class="font-semibold text-gray-700">Votre saisie :</label>
                                ${inputElementHtml}
                                <div id="${item.inputId}-feedback" class="feedback-message"></div>
                            </div>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        function getProductList() {
            const count = parseInt(formData['nombreProduits'] || 0, 10);
            const products = [];
            for (let i = 1; i <= count; i++) {
                products.push(formData[`produit_${i}`] || `Produit ${i} (non décrit)`);
            }
            return products;
        }

        function generateRandomCodes() {
            const products = getProductList();
            if (products.some(p => p.includes('(non décrit)'))) {
                alert("Veuillez d'abord décrire tous les produits dans la section 8 avant de générer les codes.");
                return;
            };

            const codes = new Set();
            while (codes.size < products.length) {
                codes.add(Math.floor(100 + Math.random() * 900));
            }

            const codeArray = Array.from(codes);
            const resultDiv = document.getElementById('code-generator-result');
            let htmlResult = '<ul class="list-disc list-inside">';
            let textResult = '';

            const productCodes = {};
            products.forEach((product, index) => {
                const code = codeArray[index];
                productCodes[product] = code;
                htmlResult += `<li class="mb-1"><span class="font-semibold">${product}:</span> ${code}</li>`;
                textResult += `${product}: ${code}\n`;
            });
            htmlResult += '</ul>';

            resultDiv.innerHTML = htmlResult;
            formData['generatedCodesHtml'] = htmlResult;
            formData['generatedCodesText'] = textResult; 
            formData['productCodes'] = productCodes;
        }

        function generatePresentationPlan() {
            const products = getProductList();
            if (products.some(p => p.includes('(non décrit)'))) {
                alert("Veuillez d'abord décrire tous les produits dans la section 8 avant de générer le plan.");
                return;
            }

            if (!formData['productCodes']) {
                alert("Veuillez d'abord générer les codes pour les produits dans la section 9.1.");
                return;
            }

            const productCodesMap = formData['productCodes'];
            const productCodes = products.map(p => productCodesMap[p]);

            const n = products.length;
            const p = parseInt(formData['panelSize'] || n, 10);
            const k = parseInt(formData['produitsParSujet'] || n, 10);

            if (k > n) {
                alert("Le nombre de produits par sujet ne peut pas être supérieur au nombre total de produits.");
                return;
            }

            let plan = [];

            if (k === n) { // Complete Block Design (Latin Square)
                let baseSquare = [];
                let firstRow = [...productCodes];
                for (let i = 0; i < n; i++) {
                    baseSquare.push([...firstRow]);
                    firstRow.push(firstRow.shift());
                }
                for (let i = 0; i < p; i++) {
                    plan.push(baseSquare[i % n]);
                }
            } else { // Incomplete Block Design (Cyclic)
                let initialBlock = productCodes.slice(0, k);
                for (let i = 0; i < p; i++) {
                    let newBlock = [];
                    let currentBlock = plan.length > 0 ? plan[plan.length - 1] : initialBlock;
                     if(i > 0) {
                        currentBlock = [];
                        const lastPlanRow = plan[i-1];
                        for(const code of lastPlanRow) {
                           const productIndex = productCodes.indexOf(code);
                           currentBlock.push(productCodes[(productIndex + 1) % n]);
                        }
                     } else {
                        currentBlock = initialBlock;
                     }
                    plan.push(currentBlock);
                }
            }

            const resultDiv = document.getElementById('latin-square-result');
            let htmlResult = `<p class="mb-2 text-sm text-gray-600">Ordre de présentation pour chaque sujet (avec codes) :</p>
                              <table class="w-full text-left border-collapse">
                                <thead><tr>
                                <th class="py-2 px-3 font-bold uppercase text-sm text-gray-600 border-b">Sujet</th>`;
            for(let i=1; i<=k; i++) {
                htmlResult += `<th class="py-2 px-3 font-bold uppercase text-sm text-gray-600 border-b text-center">Pos. ${i}</th>`;
            }
            htmlResult += `</tr></thead><tbody>`;

            let textResult = `Ordre de Présentation:\n`;
            plan.forEach((row, rowIndex) => {
                htmlResult += `<tr class="hover:bg-gray-100">`;
                htmlResult += `<td class="py-2 px-3 border-b border-gray-200 font-semibold">Sujet ${rowIndex + 1}</td>`;
                textResult += `Sujet ${rowIndex + 1}: `;
                row.forEach(code => {
                    htmlResult += `<td class="py-2 px-3 border-b border-gray-200 text-center">${code}</td>`;
                    textResult += `${code}, `;
                });
                htmlResult += `</tr>`;
                textResult = textResult.slice(0, -2) + `\n`;
            });

            htmlResult += `</tbody></table>`;
            resultDiv.innerHTML = htmlResult;
            formData['latinSquareHtml'] = htmlResult;
            formData['latinSquareText'] = textResult;
        }

        function updateProductInputs() {
            const container = document.getElementById('dynamicProductContainer');
            if (!container) return;

            const count = parseInt(formData['nombreProduits'] || 0, 10);
            let inputsHtml = '';
            for (let i = 1; i <= count; i++) {
                const savedValue = formData[`produit_${i}`] || '';
                inputsHtml += `
                    <div class="mb-3">
                        <label for="produit_${i}" class="font-semibold text-gray-700">Produit ${i}</label>
                        <input type="text" id="produit_${i}" class="form-input mt-1" value="${savedValue}">
                    </div>
                `;
            }
            container.innerHTML = inputsHtml;

            for (let i = 1; i <= count; i++) {
                const inputField = document.getElementById(`produit_${i}`);
                if (inputField) {
                    inputField.addEventListener('input', (event) => {
                        formData[`produit_${i}`] = event.target.value;
                    });
                }
            }
        }

        function updateProduitsParSujetOptions() {
            const totalProduits = parseInt(formData['nombreProduits'] || 1, 10);
            const select = document.getElementById('produitsParSujet');
            if (!select) return;

            const currentValue = parseInt(select.value, 10);
            let optionsHtml = '';
            for (let i = 1; i <= totalProduits; i++) {
                optionsHtml += `<option value="${i}">${i}</option>`;
            }
            select.innerHTML = optionsHtml;

            if (currentValue && currentValue <= totalProduits) {
                select.value = currentValue;
            } else {
                select.value = totalProduits;
            }
            formData['produitsParSujet'] = select.value;
        }

        function updatePanelSizeFeedback() {
            const feedbackDiv = document.getElementById('panelSize-feedback');
            if (!feedbackDiv) return;

            const testType = formData['testType'] || '';
            const panelSize = parseInt(formData['panelSize'] || 0, 10);
            let message = '';
            let colorClass = '';

            if (testType.includes('Triangulaire') || testType.includes('Duo-Trio')) {
                if (panelSize < 24) { message = 'Insuffisant. Un minimum de 24 sujets est recommandé pour une bonne puissance statistique.'; colorClass = 'feedback-red'; }
                else if (panelSize <= 30) { message = 'Acceptable. Pour plus de robustesse, visez plus de 30 sujets.'; colorClass = 'feedback-orange'; }
                else { message = 'Optimal. Ce nombre de sujets est excellent pour ce type de test.'; colorClass = 'feedback-green'; }
            } else if (testType.includes('Descriptive') || testType.includes('Profil')) {
                if (panelSize < 8) { message = 'Insuffisant. Un panel entraîné requiert au moins 8 sujets.'; colorClass = 'feedback-red'; }
                else if (panelSize > 15) { message = 'Élevé. Assurez-vous de pouvoir maintenir l\'homogénéité du panel.'; colorClass = 'feedback-orange'; }
                else { message = 'Optimal. La taille du panel est idéale pour un test descriptif.'; colorClass = 'feedback-green'; }
            } else if (testType.includes('Hédonique') || testType.includes('Préférence') || testType.includes('JAR')) {
                if (panelSize < 60) { message = 'Très insuffisant pour un test consommateur. Visez au moins 60-80 sujets.'; colorClass = 'feedback-red'; }
                else if (panelSize < 80) { message = 'Acceptable pour des tendances, mais 80+ est recommandé pour des résultats fiables.'; colorClass = 'feedback-orange'; }
                else { message = 'Optimal. Ce nombre de consommateurs est robuste pour un test affectif.'; colorClass = 'feedback-green'; }
            } else {
                message = '';
            }

            feedbackDiv.textContent = message;
            feedbackDiv.className = `feedback-message ${colorClass}`;
            feedbackDiv.style.display = message ? 'block' : 'none';
        }

        function renderSection(section) {
            const container = document.getElementById('content-container');
            if (section.id === 'introduction') {
                container.innerHTML = section.content;
            } else {
                container.innerHTML = `
                    <h2 class="text-3xl font-bold mb-6">${section.title}</h2>
                    <div id="accordion-container">
                        ${renderAccordions(section.items)}
                    </div>`;
            }

            document.querySelectorAll('.accordion-header').forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const isOpen = content.classList.contains('open');
                    document.querySelectorAll('.accordion-content.open').forEach(openContent => {
                        openContent.classList.remove('open');
                        openContent.previousElementSibling.classList.remove('open');
                    });
                    if (!isOpen) {
                        content.classList.add('open');
                        header.classList.add('open');
                    }
                });
            });

            if (section.items) {
                section.items.forEach(item => {
                    if (item.inputId) {
                        const inputField = document.getElementById(item.inputId);
                        if (inputField) {
                            const eventType = inputField.tagName.toLowerCase() === 'select' ? 'change' : 'input';
                            inputField.addEventListener(eventType, (event) => {
                                formData[item.inputId] = event.target.value;
                                if (item.inputId === 'nombreProduits') {
                                    updateProduitsParSujetOptions();
                                    updateProductInputs();
                                }
                                if (item.inputId === 'panelSize') {
                                    updatePanelSizeFeedback();
                                }
                            });
                        }
                    }
                });
            }

            if (document.getElementById('dynamicProductContainer')) {
                updateProductInputs();
            }

            if(document.getElementById('produitsParSujet')) {
                updateProduitsParSujetOptions();
            }

            if(document.getElementById('decision-tree-container')) {
                setupDecisionTree();
            }

            if (document.getElementById('panelSize')) {
                updatePanelSizeFeedback();
            }

            const codeGenButton = document.getElementById('code-generator-button');
            if (codeGenButton) {
                codeGenButton.addEventListener('click', generateRandomCodes);
            }

            const latinSquareButton = document.getElementById('latin-square-button');
            if (latinSquareButton) {
                latinSquareButton.addEventListener('click', generatePresentationPlan);
            }
        }

        function exportToPdf() {
            if (typeof window.jspdf === 'undefined') {
                alert("La librairie d'exportation PDF n'a pas pu être chargée. Veuillez vérifier votre connexion internet et réessayer.");
                return;
            }
            const { jsPDF } = window.jspdf;

            toggleLoading(true, 'Exportation en cours...');

            setTimeout(() => {
                try {
                    const doc = new jsPDF({
                        orientation: 'p',
                        unit: 'mm',
                        format: 'a4'
                    });
                    const margin = 15;
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const usableWidth = pageWidth - 2 * margin;
                    let y = margin;

                    const protocolTitle = formData['titre'] || "Protocole Sensoriel";

                    doc.setFont('helvetica', 'bold');
                    const titleLines = doc.splitTextToSize(protocolTitle, usableWidth);
                    doc.text(titleLines, pageWidth / 2, y, { align: 'center' });
                    y += titleLines.length * 8 + 5;

                    for (const section of protocolData.sections) {
                        if (!section.items) continue;

                        if (y > pageHeight - margin - 20) {
                            doc.addPage();
                            y = margin;
                        }

                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(14);
                        doc.setTextColor(93, 33, 187);
                        doc.text(section.title, margin, y);
                        y += 8;

                        for (const item of section.items) {
                            if (y > pageHeight - margin - 15) {
                                doc.addPage();
                                y = margin;
                            }
                            doc.setFont('helvetica', 'bold');
                            doc.setFontSize(11);
                            doc.setTextColor(0, 0, 0);

                            const itemTitleLines = doc.splitTextToSize(item.title, usableWidth);
                            doc.text(itemTitleLines, margin, y);
                            y += itemTitleLines.length * 5;

                            let value = "Non renseigné";
                            if (item.inputId) {
                                value = formData[item.inputId] || "Non renseigné";
                            } else if (item.type === 'dynamic') {
                                const count = parseInt(formData['nombreProduits'] || 0, 10);
                                let productDescriptions = '';
                                for(let i = 1; i <= count; i++) {
                                    productDescriptions += `Produit ${i}: ${formData['produit_' + i] || 'Non décrit'}\n`;
                                }
                                value = productDescriptions.trim() || "Aucun produit décrit";
                            } else if (item.interactive && item.title.includes('Codage')) {
                                value = formData['generatedCodesText'] || "Non généré";
                            } else if (item.interactive && item.title.includes('Ordre')) {
                                value = formData['latinSquareText'] || "Non généré";
                            } else if (item.type === 'interactive-tree') {
                                value = formData['testType'] || "Non sélectionné";
                            }

                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(10);
                            doc.setTextColor(75, 85, 99);

                            const valueLines = doc.splitTextToSize(value, usableWidth);
                             if (y + (valueLines.length * 4.5) > pageHeight - margin) {
                                doc.addPage();
                                y = margin;
                            }
                            doc.text(valueLines, margin + 5, y);
                            y += valueLines.length * 4.5 + 5;
                        }
                        y += 5;
                    }
                    doc.save(`${protocolTitle.replace(/ /g, '_')}.pdf`);
                } catch (error) {
                    console.error("Erreur lors de la génération du PDF:", error);
                    alert("Une erreur est survenue lors de la création du PDF. Veuillez consulter la console pour plus de détails.");
                } finally {
                    toggleLoading(false);
                }
            }, 50);
        }

        function buildNav() {
            const navContainer = document.getElementById('main-nav');
            protocolData.sections.forEach(section => {
                const link = document.createElement('a');
                link.className = 'nav-link';
                link.dataset.section = section.id;
                link.innerHTML = `${section.icon} ${section.title}`;
                navContainer.appendChild(link);
            });
        }

        function handleNavigation() {
            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => {
                link.addEventListener('click', () => {
                    const sectionId = link.dataset.section;
                    navLinks.forEach(l => l.classList.remove('active'));
                    link.classList.add('active');
                    const sectionData = protocolData.sections.find(s => s.id === sectionId);

                    const container = document.getElementById('content-container');
                    container.style.opacity = 0;
                    setTimeout(() => {
                        renderSection(sectionData);
                        container.style.opacity = 1;
                        container.scrollTop = 0;
                        document.querySelector('.accordion-header')?.click();
                    }, 200);
                });
            });
        }

        function setupDecisionTree() {
            const container = document.getElementById('decision-tree-container');
            if (!container) return;

            const tree = {
                start: {
                    question: "Quel type de mesure souhaitez-vous réaliser ?",
                    options: [
                        { text: "Test Sensoriel (avec des sujets humains)", next: 'sensoriel_objectif' },
                        { text: "Test Instrumenté (mesure physique)", next: 'instrumental' },
                        { text: "Autre type de test", final: 'Autre (à préciser)' }
                    ]
                },
                instrumental: {
                    question: "Quelle propriété principale souhaitez-vous mesurer ?",
                    options: [
                        { text: "Texture (dureté, élasticité, etc.)", final: 'Analyse de Texture (Texturomètre)' },
                        { text: "Couleur", final: 'Colorimétrie (Colorimètre)' },
                        { text: "Arômes (composés volatils)", final: 'Analyse Chromatographique (CPG-MS)' },
                        { text: "Goût (sucré, acidité...)", final: 'Analyse Physico-chimique (pH-mètre, Réfractomètre...)' }
                    ]
                },
                sensoriel_objectif: {
                    question: "Quel est l'objectif principal de votre test sensoriel ?",
                    options: [
                        { text: "Comparer des produits (y a-t-il une différence ?)", next: 'discriminatif' },
                        { text: "Décrire des produits (quelles sont leurs caractéristiques ?)", next: 'descriptif' },
                        { text: "Mesurer l'appréciation (les produits sont-ils aimés ?)", next: 'affectif' }
                    ]
                },
                discriminatif: {
                    question: "La question est-elle simplement 'différent ou pas' ou 'lequel est le plus intense/préféré' ?",
                    options: [
                        { text: "Différent ou pas (global)", next: 'discriminatif_global' },
                        { text: "Plus intense / Préféré", final: 'Comparaison par Paires' }
                    ]
                },
                discriminatif_global: {
                    question: "Comment voulez-vous présenter les échantillons ?",
                    options: [
                        { text: "3 échantillons (2 identiques, 1 différent)", final: 'Test Triangulaire' },
                        { text: "1 référence + 2 échantillons", final: 'Test Duo-Trio' }
                    ]
                },
                descriptif: {
                    question: "Avez-vous besoin d'un profil complet et quantifié ou d'une description plus rapide ?",
                    options: [
                        { text: "Profil complet et quantifié", next: 'descriptif_complet' },
                        { text: "Description rapide/comparative", final: 'Profil Flash' }
                    ]
                },
                descriptif_complet: {
                    question: "Quelle méthode descriptive souhaitez-vous utiliser ?",
                    options: [
                        { text: "Profil Sensoriel Conventionnel", final: 'Profil Sensoriel Conventionnel' },
                        { text: "Analyse Descriptive Quantitative (QDA®)", final: 'Analyse Descriptive Quantitative (QDA®)' }
                    ]
                },
                affectif: {
                    question: "Voulez-vous mesurer le niveau de plaisir, classer par préférence, ou optimiser un attribut ?",
                    options: [
                        { text: "Niveau de plaisir", final: 'Échelle Hédonique' },
                        { text: "Classer par préférence", final: 'Classement par Préférence' },
                        { text: "Optimiser un attribut", final: 'Échelles JAR (Just About Right)' }
                    ]
                }
            };

            function renderNode(nodeKey) {
                const node = tree[nodeKey];
                container.innerHTML = '';

                const breadcrumb = document.createElement('div');
                breadcrumb.className = 'breadcrumb';
                let path = 'Accueil';
                treeHistory.forEach(step => {
                    path += ` > ${step.text}`;
                });
                breadcrumb.textContent = path;
                container.appendChild(breadcrumb);

                const question = document.createElement('p');
                question.className = 'font-semibold mb-3';
                question.textContent = node.question;
                container.appendChild(question);

                const optionsContainer = document.createElement('div');
                container.appendChild(optionsContainer);

                node.options.forEach(option => {
                    const button = document.createElement('button');
                    button.className = 'tree-node';
                    button.textContent = option.text;
                    button.onclick = () => {
                        treeHistory.push({ key: option.next || option.final, text: option.text });
                        if (option.next) {
                            renderNode(option.next);
                        } else if (option.final) {
                            selectFinal(option.final);
                        }
                    };
                    optionsContainer.appendChild(button);
                });

                if (treeHistory.length > 0) {
                    const backButton = document.createElement('button');
                    backButton.textContent = 'Précédent';
                    backButton.className = 'text-sm text-blue-600 hover:underline mt-4';
                    backButton.onclick = () => {
                        treeHistory.pop();
                        const previousNodeKey = treeHistory.length > 0 ? treeHistory[treeHistory.length - 1].key : 'start';
                        treeHistory.pop(); // Pop again to remove the step we are going back to, it will be re-added
                        renderNode(previousNodeKey);
                    };
                    container.appendChild(backButton);
                }
            }

            function selectFinal(testType) {
                formData['testType'] = testType;
                updatePanelSizeFeedback();
                let breadcrumbHtml = '<div class="breadcrumb">Votre chemin : ';
                treeHistory.forEach((step, index) => {
                    breadcrumbHtml += `${step.text}${index < treeHistory.length - 1 ? ' > ' : ''}`;
                });
                breadcrumbHtml += '</div>';

                let resultHtml = `${breadcrumbHtml}<p class="font-semibold">Test sélectionné :</p>
                                  <div class="p-3 mt-2 bg-green-100 border border-green-300 rounded-lg text-green-800 font-bold">
                                    ${testType}
                                  </div>`;
                if (testType.includes('Autre')) {
                    resultHtml += `<div id="autreTestTypeContainer" class="mt-4">
                                <label for="autreTestType" class="font-semibold text-gray-700">Précisez le type de test :</label>
                                <input type="text" id="autreTestType" class="form-input mt-1" value="${formData['autreTestType'] || ''}">
                            </div>`;
                }
                resultHtml += `<button id="reset-tree" class="text-sm text-blue-600 hover:underline mt-4">Recommencer la sélection</button>`;
                container.innerHTML = resultHtml;

                document.getElementById('reset-tree').onclick = () => {
                    delete formData.testType;
                    delete formData.autreTestType;
                    treeHistory = [];
                    updatePanelSizeFeedback();
                    renderNode('start');
                };

                const autreInput = document.getElementById('autreTestType');
                if (autreInput) {
                    autreInput.addEventListener('input', (e) => {
                        formData['autreTestType'] = e.target.value;
                        formData['testType'] = e.target.value; // Also update the main field
                    });
                }
            }

            if (formData['testType']) {
                selectFinal(formData['testType']);
            } else {
                treeHistory = [];
                renderNode('start');
            }
        }

        function init() {
            buildNav();
            handleNavigation();
            document.querySelector('.nav-link[data-section="introduction"]').click();
            document.getElementById('export-pdf-button').addEventListener('click', exportToPdf);
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>










